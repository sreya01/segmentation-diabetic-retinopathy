# -*- coding: utf-8 -*-
"""Untitled112.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16WqSLv51rPAsp6Vsup2Ze4nVBdUm4nrx
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping

def build_fpn_classifier(input_shape, num_classes=1):
    inputs = layers.Input(shape=input_shape)
    backbone = tf.keras.applications.ResNet50(include_top=False, weights='imagenet', input_tensor=inputs)
    x1 = backbone.get_layer('conv4_block6_out').output
    x2 = layers.UpSampling2D(size=(2, 2))(x1)
    x3 = layers.Concatenate()([x1, x2])
    x3 = layers.Conv2D(256, (3, 3), activation='relu', padding='same')(x3)
    x4 = layers.UpSampling2D(size=(2, 2))(x3)
    x4 = layers.Conv2D(128, (3, 3), activation='relu', padding='same')(x4)
    x5 = layers.GlobalAveragePooling2D()(x4)
    x6 = layers.Dense(128, activation='relu')(x5)
    output = layers.Dense(num_classes, activation='sigmoid')(x6)
    model = models.Model(inputs, output)
    return model

def preprocess_data(image_data, target_size=(224, 224)):
    resized_images = tf.image.resize(image_data, target_size)
    resized_images = np.expand_dims(resized_images, axis=-1)
    return resized_images

def prepare_data(segmentation_output):
    image_data = []
    for img in segmentation_output:
        image_data.append(preprocess_data(img))
    return np.array(image_data)

def prepare_labels(labels, num_classes=4):
    label_encoder = LabelEncoder()
    labels = label_encoder.fit_transform(labels)
    labels = tf.keras.utils.to_categorical(labels, num_classes=num_classes)
    return labels

def split_data(image_data, labels, test_size=0.2):
    X_train, X_test, y_train, y_test = train_test_split(image_data, labels, test_size=test_size, random_state=42)
    return X_train, X_test, y_train, y_test

def data_augmentation(X_train, y_train):
    datagen = ImageDataGenerator(
        rotation_range=20,
        width_shift_range=0.2,
        height_shift_range=0.2,
        shear_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True,
        fill_mode='nearest'
    )
    datagen.fit(X_train)
    return datagen

def evaluate_model(model, X_test, y_test):
    test_loss, test_acc = model.evaluate(X_test, y_test, verbose=2)
    print(f"Test accuracy: {test_acc}")
    return test_loss, test_acc

def plot_predictions(predictions, class_names, image_idx=0):
    predicted_class = class_names[np.argmax(predictions[image_idx])]
    print(f"Predicted Class: {predicted_class}")
    plt.imshow(predictions[image_idx, :, :, 0], cmap='gray')
    plt.title(predicted_class)
    plt.show()

def save_model(model, filepath="fpn_classifier_model.h5"):
    model.save(filepath)
    print(f"Model saved at {filepath}")

def load_model(filepath="fpn_classifier_model.h5"):
    model = models.load_model(filepath)
    print(f"Model loaded from {filepath}")
    return model

def main():
    segmentation_output = np.load('segmentation_output.npy')
    labels = np.load('labels.npy')

    image_data = prepare_data(segmentation_output)
    labels = prepare_labels(labels)

    X_train, X_test, y_train, y_test = split_data(image_data, labels, test_size=0.2)

    fpn_classifier = build_fpn_classifier((224, 224, 1), num_classes=1)
    fpn_classifier.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

    datagen = data_augmentation(X_train, y_train)

    checkpoint_callback = ModelCheckpoint('fpn_classifier_best_model.h5', monitor='val_loss', save_best_only=True, verbose=1)
    early_stopping_callback = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True, verbose=1)

    history = fpn_classifier.fit(datagen.flow(X_train, y_train, batch_size=32),
                                 validation_data=(X_test, y_test),
                                 epochs=50,
                                 steps_per_epoch=len(X_train) // 32,
                                 callbacks=[checkpoint_callback, early_stopping_callback])

    evaluate_model(fpn_classifier, X_test, y_test)

    test_predictions = fpn_classifier.predict(X_test)
    plot_predictions(test_predictions, ['Diabetric Retinopathy','Normal Fundus Image'], image_idx=0)

    save_model(fpn_classifier)

    loaded_model = load_model('fpn_classifier_best_model.h5')
    test_predictions_loaded = loaded_model.predict(X_test)
    plot_predictions(test_predictions_loaded, ['DR', 'Non-DR'], image_idx=1)

if __name__ == "__main__":
    main()